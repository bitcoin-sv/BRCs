# BRC-97: Zero Knowledge Proof Type Format for Future Verification of Specific Key Linkage Claims

Ty Everett (ty@projectbabbage.com)

## Abstract

As discussed in BRC-93, there are limitations to BRC-69 specific key linkage revelation. BRC-94 addresses counterparty-level verification with a Schnorr scheme, but we are still left without a way to prove specific key linkages. ZKP techniques are still in their nascent stages, with new capabilities being developed. This specification makes room for future proof schemes to emerge, while acknowledging current limitations. It proposes a proof type numbering scheme, starting at zero, where each subsequent number (1 through 255) represents a new scheme. This way, as new proof capabilities are developed, wallets can adopt them and return proofs in various formats, with the hope that standards will converge on one unified format over time.

## Motivation

We need a way to prove BRC-69 method 2 specific key linkage revelations, but ZKP technology is still in its infancy. We want to proceed with the standardization process around digital wallets for a myriad of reasons, but are hesitant to embrace a singular approach to linkage proof revelation without the possibility of future extensibility. This document is motivated by the desire to create an extensible field for specific key linkage revelation proof data, opening up the playing field for novel ZKP techniques over time.

## Scope and Assumptions

We constrain the scope to proofs of a very specific type: that Alice computed a shared secret between herself and Bob, and she used it as a SHA-256-HMAC key over the appropriate invoice number, to arrive at a given specific linkage offset value. Proofs over any other computation are out-of-scope, because this is how the wallet derives specific child keys.

We make a few assumptions about the future:
1. Schemes need to be non-interfactive. Any interactive scheme is out-of-scope. With STARKs already available, we know that non-interactive approaches are possible, and we choose to wait for those to develop further.
2. Verification by an external party. We do not provide a mechanism, within the wallet itself, to verify proofs. We expect that external systems will verify proofs, and the wallet merely generates them. We will not support asking the wallet to verify a generated proof.
3. Encryptable proof payload. We assume that, whatever form the proof payload takes, it will be encrypted by the prover for the verifier. The assumption is that the verifier can decrypt the proof payload and use it to verify the revealed linkage value was computed correctly.

## Specification

We use this document to specify a few things about the Wallet API, and the ways that these proofs are generated and managed.

We expand the scope slightly, for the purposes of having one BRC, so that we can also talk about how BRC-94 integrates for counterparty-level revelation, and the Schnorr serialization format.

### Proof Encryption with BRC-72

We start with the encryption scheme described in BRC-72, which is used to secure information about the BRC-69 linkage offsets themselves, across its both methods.

We specify that, for the purposes of wallets communicating proofs, they should be encrypted in the same way, with the same scheme.
- For counterparty-level revelation, BRC-72 style encrypted BRC-94 Schnorr proofs are returned alongside the encrypted shared secret
- For specific revelation, BRC-72 style encrypted proofs of the format described under this BRC-97 document are returned alongside the encrypted linkage offset (together with a proof type between 0 and 255, as covered later)

### Counterparty (BRC-94) Proof Format

We specify a binary format for the encrypted BRC-94 Schnorr proof payload, as follows:

**Field** | **Bytes** | **Format**
----------|-----------|-----------
R         | 1-33      | R point in 33-byte DER format
S Prime   | 34-66     | S Prime point in 33-byte DER format
z         | 67-rest   | z value (big endian)

This binary data is assembled in the above format, then encrypted as per BRC-72 alongside the shared secret, and returned by the wallet for the verifier.

### Specific (BRC-97) Extensible Proof Type Identifier and Proof Format

As above, we specify a binary format for the encrypted payload, as follows:

**Field**  | **Bytes** | **Format**
-----------|-----------|-----------
Proof Type | 1         | One-byte (0-255) Proof Type Identifier as an unsighed integer
Proof      | rest      | Proof payload (if applicable and present, depending on Proof Type identifier)

This binary data is assembled in the above format, then encrypted as per BRC-72 alongside the specific linkage, and returned by the wallet for the verifier.

### Proof Type Zero

We specify that Proof Type zero denotes the absence of any zero-knowledge proof on the specific key linkage.

Verifiers must trust the prover when the proof type is zero. The payload is empty.

## Future Work

Future specifications may cover proof types other than type zero, from 1 to 255.
