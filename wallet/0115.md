# BRC-115: Wallet Permissions and Counterparty Trust

- Stephen Thomson (stephen@projectbabbage.com)
- Brayden Langley (brayden@projectbabbage.com)
- Jackie Lu       (jackie@projectbabbage.com)

## Abstract

This document fully specifies how BRC-100 wallets handle application permission requests.

Its goals are to:
- Define, without ambiguity, how permissions are declared, requested, and evaluated
- Specify full permission lifecycle behavior: grant, deny, renew, revoke, and persistence
- Distinguish **group permissions** from **counterparty trust (PACT)** and define how both are enforced together
- Provide an authoritative, implementation-agnostic reference for compliant wallet behavior

This document is **normative**: it defines complete expected behavior for compliant wallets and applications, independent of UI or implementation language.

---

## Motivation

Wallets act as security boundaries between users and applications.  
Applications must not be able to:
- Spend funds
- Access private data
- Interact with protocols
- Access certificates

...without **explicit user authorization**.

The permissions system ensures:
- Least-privilege access
- Clear user consent
- Deterministic enforcement
- Predictable developer behavior

## Normative Language

The key words **MUST**, **MUST NOT**, **SHOULD**, and **MAY** in this document are to be interpreted as described in RFC 2119 and RFC 8174 when, and only when, they appear in all capitals.

---

## Specification

### 3.0 Terminology

The following terms are used consistently throughout this document:

- **Wallet**: Software responsible for enforcing permissions and managing user assets and data.
- **Application (Originator)**: Software acting as an originator that requests permissions from the wallet. Identified by its domain (e.g. `example.com`).
- **User**: The human owner of the wallet who grants or denies permissions.
- **Counterparty**: An external entity (identified by a compressed public key) interacting with the user through an application via Level 2 protocols.
- **Permission Grant**: A persisted authorization allowing an originator to perform a specific action within defined scope.
- **Permission Token**: An on-chain PushDrop output stored in an admin basket that represents a persisted permission grant. Tokens are encrypted so only the wallet owner can read them. See Section 7.
- **Security Level**: An integer (0, 1, or 2) that classifies protocol access. **Level 0** is open (no permission required). **Level 1** protocols are application-scoped. **Level 2** protocols are counterparty-specific (a distinct external entity is involved). The [BRC-43](https://brc.dev/43) specification defines how these are applied and used within cryptographic operations.
- **Manifest**: A JSON file served at `https://{domain}/manifest.json` providing application metadata. See Section 3.2.
- **Trusted Certifier**: An entity the user has chosen to trust, identified by a compressed public key and assigned a trust score (1-10). Used for registry resolution and identity verification.

For the purposes of this document, **group permissions** refer to permissions granted by a user to an application originator via the wallet's standard permission system. These are distinct from **PACT** (counterparty trust), which governs trust relationships with external entities (see Section 5).

### 3.1 Originator

An **originator** represents the identity of an application requesting permissions, derived from the application's domain.

Permissions are always scoped to an originator.
Granting permission to one originator does **not** imply permission for another.

The wallet resolves originator identity from the request context (typically HTTP headers such as `Origin` or `Originator`) when evaluating permission scope.

**Security Note:** The user's wallet, web browser and computer system are expected to coordinate and confirm the authenticity of originators, thereby preventing request forgery. The steps taken to confirm originator authenticity vary depending on wallet deployment context, but this specification assumes wallets will prevent forged requests via IPC, local kernel/substrate-specific authentication, or other means.

---

### 3.2 Manifest

Each application SHOULD serve a **manifest** file at `https://{domain}/manifest.json`.

The manifest follows the [W3C Web App Manifest](https://www.w3.org/TR/appmanifest/) standard for application metadata (name, icons, display preferences), and extends it with a `metanet` namespace for wallet permission declarations. This keeps the manifest interoperable with standard web tooling while adding Metanet-specific capabilities.

The manifest serves three purposes:

1. **Application metadata** - Standard W3C fields (`name`, `short_name`, `description`, `icons`) for display in permission prompts and the wallet dashboard.
2. **Group permission declarations** - Under `metanet.groupPermissions`, applications declare the permissions they need. When grouped permission seeking is enabled, the wallet fetches these declarations and presents them to the user as a single grouped prompt on first interaction, rather than prompting one-by-one as each capability is used.
3. **Counterparty permission declarations** - Under `metanet.counterpartyPermissions`, applications declare the Level 2 protocols they require for peer interaction in that app. When a new (untrusted) counterparty is encountered, the wallet uses this declaration to request trust for those protocols before allowing that peer interaction to proceed.

#### Manifest Structure

```json
{
  "name": "My Application",
  "short_name": "MyApp",
  "description": "A web application with Metanet permissions.",
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "metanet": {
    "schemaVersion": 1,
    "groupPermissions": {
      "description": "Permissions needed by this application",
      "spendingAuthorization": {
        "amount": 10000,
        "description": "Monthly spending limit for transactions"
      },
      "protocolPermissions": [
        {
          "protocolID": [2, "myprotocol"],
          "counterparty": "<counterpartyPublicKey>",
          "description": "Peer messaging"
        }
      ],
      "basketAccess": [
        {
          "basket": "my-tokens",
          "description": "Token storage"
        }
      ],
      "certificateAccess": [
        {
          "type": "<certTypeBase64>",
          "verifierPublicKey": "02...",
          "fields": ["name", "email"],
          "description": "Identity verification"
        }
      ]
    },
    "counterpartyPermissions": {
      "description": "Peer trust required by this application",
      "protocols": [
        {
          "protocolName": "myprotocol",
          "description": "Peer-to-peer messaging"
        }
      ]
    }
  }
}
```

All fields under `metanet` are optional except `schemaVersion`. An application that declares no `metanet.groupPermissions` will simply be prompted individually at runtime for each capability it uses. An application that declares no `metanet.counterpartyPermissions` will never trigger a PACT prompt - Level 2 protocol requests will fall through to individual or grouped permission prompts instead.

#### Schema Version

The `metanet.schemaVersion` field is a required integer that identifies the version of the Metanet permission schema. Wallets MUST check this field and handle unknown versions gracefully (e.g. by ignoring the `metanet` block or warning the user). The current version is `1`.

#### Group Permissions Declaration

The `metanet.groupPermissions` object follows the `GroupedPermissions` interface ([BRC-73](https://brc.dev/73)):

| Field | Type | Description |
|-------|------|-------------|
| `description` | string? | Human-readable description of the permission group |
| `spendingAuthorization` | `{ amount, description }` | Monthly spending limit in satoshis |
| `protocolPermissions` | array | Protocol access requests (Level 1 or 2). Level 2 entries MUST include a specific `counterparty`; Level 1 entries MAY omit `counterparty`. |
| `basketAccess` | array | Basket access requests, each with a `basket` name |
| `certificateAccess` | array | Certificate access requests with `type`, `verifierPublicKey`, `fields` |

When the wallet encounters a permission-requiring operation, it MUST:
1. Check whether a permission token already exists for this operation. If so, allow the operation. Otherwise, proceed with step 2.
2. Fetch the originator's manifest.
3. Check whether the current operation is covered by the manifest's `groupPermissions`. If it is not, trigger a one-off prompt for the operation. If it is, proceed with step 4.
4. Filter out permissions already granted (by looking up existing on-chain tokens). Remove them from the list before showing the user a prompt.
5. Present all remaining permissions as a single grouped prompt for the user's approval.
6. After the user responds, check whether the specific triggering operation is now satisfied. If yes, allow it to proceed with the operation. If no, trigger an individual one-off prompt.

#### Counterparty Permissions Declaration

The `metanet.counterpartyPermissions` object declares PACT requirements - the Level 2 protocol set the application requires to interact with a peer in that app:

| Field | Type | Description |
|-------|------|-------------|
| `description` | string? | Human-readable description |
| `protocols` | array | Array of `{ protocolName, description }` - required peer-interaction protocols, interpreted as **Level 2 only** |

The wallet MUST enforce that all declared `counterpartyPermissions.protocols` entries include a non-empty `protocolName`. These entries are interpreted as Level 2 protocol declarations.
These declarations define required Level 2 protocols, while the concrete counterparty is supplied at request time. Effective permission scope remains per-originator + per-counterparty.

Including `counterpartyPermissions` tells the wallet: "when this app encounters a new (untrusted) counterparty, request trust for this declared protocol set before allowing peer interaction to proceed." Without it, each Level 2 protocol permission is requested individually as it's used.

#### Manifest Examples

**Example 1: Simple app with spending only**

An application that only needs to spend satoshis (e.g. a tipping service):

```json
{
  "name": "Tip Jar",
  "short_name": "TipJar",
  "description": "Send tips to content creators.",
  "start_url": ".",
  "display": "standalone",
  "icons": [{ "src": "icon.png", "sizes": "192x192", "type": "image/png" }],
  "metanet": {
    "schemaVersion": 1,
    "groupPermissions": {
      "description": "Spending permission for sending tips",
      "spendingAuthorization": {
        "amount": 50000,
        "description": "Monthly tip budget (50,000 satoshis)"
      }
    }
  }
}
```

**Example 2: Data storage app (baskets, no counterparties)**

An application that stores encrypted notes in a basket using a Level 1 protocol:

```json
{
  "name": "Secure Notes",
  "short_name": "Notes",
  "description": "Encrypted personal notes on the blockchain.",
  "start_url": ".",
  "display": "standalone",
  "icons": [{ "src": "icon.png", "sizes": "192x192", "type": "image/png" }],
  "metanet": {
    "schemaVersion": 1,
    "groupPermissions": {
      "description": "Storage and encryption permissions",
      "protocolPermissions": [
        {
          "protocolID": [1, "secure-notes"],
          "description": "Encrypt and decrypt your notes"
        }
      ],
      "basketAccess": [
        {
          "basket": "encrypted-notes",
          "description": "Store your encrypted notes"
        }
      ]
    }
  }
}
```

**Example 3: Peer-to-peer messaging (with counterparty permissions)**

An application where users exchange messages with specific counterparties. This declares `counterpartyPermissions` so the wallet will prompt the user to establish trust (PACT) when a new counterparty is encountered:

```json
{
  "name": "Peer Messenger",
  "short_name": "PeerMsg",
  "description": "End-to-end encrypted messaging.",
  "start_url": ".",
  "display": "standalone",
  "icons": [{ "src": "icon.png", "sizes": "192x192", "type": "image/png" }],
  "metanet": {
    "schemaVersion": 1,
    "groupPermissions": {
      "description": "Messaging permissions",
      "protocolPermissions": [],
      "basketAccess": [
        {
          "basket": "message-inbox",
          "description": "Store received messages"
        }
      ],
      "spendingAuthorization": {
        "amount": 5000,
        "description": "Transaction fees for sending messages"
      }
    },
    "counterpartyPermissions": {
      "description": "Trust required to communicate with a peer",
      "protocols": [
        {
          "protocolName": "peer-messaging",
          "description": "Allow this person to send you encrypted messages"
        },
        {
          "protocolName": "peer-presence",
          "description": "Share your online status with this person"
        }
      ]
    }
  }
}
```

**Example 4: Identity verification app (certificates)**

An application that verifies user identity by requesting specific certificate fields:

```json
{
  "name": "KYC Portal",
  "short_name": "KYC",
  "description": "Identity verification for regulated services.",
  "start_url": ".",
  "display": "standalone",
  "icons": [{ "src": "icon.png", "sizes": "192x192", "type": "image/png" }],
  "metanet": {
    "schemaVersion": 1,
    "groupPermissions": {
      "description": "Identity verification permissions",
      "certificateAccess": [
        {
          "type": "AGbsvkGHSi78y1FR6JL0Ig==",
          "verifierPublicKey": "0294c479f762f3571c4c36f6a75f04995ddcf200777b704131ca71dab5b0e19bfb",
          "fields": ["firstName", "lastName", "dateOfBirth"],
          "description": "Verify your legal name and date of birth"
        },
        {
          "type": "AGbsvkGHSi78y1FR6JL0Ig==",
          "verifierPublicKey": "0294c479f762f3571c4c36f6a75f04995ddcf200777b704131ca71dab5b0e19bfb",
          "fields": ["country", "address"],
          "description": "Verify your address for compliance"
        }
      ]
    }
  }
}
```

**Example 5: Full-featured application (all permission types + PACT)**

```json
{
  "name": "Decentralized Marketplace",
  "short_name": "DeMarket",
  "description": "Buy and sell goods with on-chain escrow.",
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#1a1a2e",
  "background_color": "#ffffff",
  "icons": [
    { "src": "icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "icon-512.png", "sizes": "512x512", "type": "image/png" }
  ],
  "metanet": {
    "schemaVersion": 1,
    "groupPermissions": {
      "description": "Marketplace permissions",
      "spendingAuthorization": {
        "amount": 1000000,
        "description": "Monthly purchase and escrow budget"
      },
      "protocolPermissions": [
        {
          "protocolID": [1, "marketplace-listings"],
          "description": "Create and manage your product listings"
        },
        {
          "protocolID": [2, "escrow-negotiation"],
          "counterparty": "02bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
          "description": "Negotiate escrow terms with buyers/sellers"
        },
        {
          "protocolID": [2, "trade-messaging"],
          "counterparty": "02bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
          "description": "Exchange messages during a trade"
        }
      ],
      "basketAccess": [
        {
          "basket": "marketplace-listings",
          "description": "Your active product listings"
        },
        {
          "basket": "escrow-contracts",
          "description": "Active escrow agreements"
        },
        {
          "basket": "trade-receipts",
          "description": "Completed trade receipts"
        }
      ],
      "certificateAccess": [
        {
          "type": "AGbsvkGHSi78y1FR6JL0Ig==",
          "verifierPublicKey": "0294c479f762f3571c4c36f6a75f04995ddcf200777b704131ca71dab5b0e19bfb",
          "fields": ["displayName"],
          "description": "Display your verified name to trade partners"
        }
      ]
    },
    "counterpartyPermissions": {
      "description": "Trust required to trade with a peer",
      "protocols": [
        {
          "protocolName": "escrow-negotiation",
          "description": "Negotiate escrow terms with this trader"
        },
        {
          "protocolName": "trade-messaging",
          "description": "Exchange messages with this trader"
        }
      ]
    }
  }
}
```

**Example 6: Minimal manifest (no Metanet permissions)**

An application that does not declare any permissions upfront. The wallet will prompt individually as each capability is used:

```json
{
  "name": "Simple App",
  "short_name": "Simple",
  "description": "A basic application.",
  "start_url": ".",
  "display": "standalone",
  "icons": [{ "src": "favicon.ico", "sizes": "64x64", "type": "image/x-icon" }]
}
```

#### BRC-68 Trust Extension

The `metanet.trust` object is used when adding trusted certifiers (see Section 5.8), not for application permission requests. Its fields are validated as follows:

| Field | Constraint |
|-------|-----------|
| `name` | 5-30 characters |
| `note` | 5-50 characters (optional in some contexts) |
| `icon` | Must be a valid image URL |
| `publicKey` | Compressed public key matching `/^(02|03)[a-fA-F0-9]{64}$/` |

---

### 3.3 Permission Categories

The system defines four primary permission types:

| # | Type | Protocol Acronym | Scope Key | Counterparty-Aware |
|---|------|-----------------|-----------|-------------------|
| 1 | Protocol Permissions | DPACP (Domain Protocol Access Control Protocol) | `protocolID` (security level + name) | Yes (Level 2) |
| 2 | Spending Permissions | DSAP (Domain Spending Authorization Protocol) | Satoshi amount | No |
| 3 | Basket Permissions | DBAP (Domain Basket Access Protocol) | Basket name | No |
| 4 | Certificate Permissions | DCAP (Domain Certificate Access Protocol) | Certificate type + verifier + fields | No |

Each permission type has distinct scope, grant options, and prompting behavior. All four types support a **renewal** flag indicating the permission is being re-requested after a previous grant has expired (when finite expiry is used) or been revoked.

### 3.4 Deterministic Permission Evaluation

To remove ambiguity across implementations:

- Wallets MUST make allow/deny decisions from canonical permission state: valid, unspent, unexpired on-chain permission tokens plus explicit one-time ephemeral grants for the current request.
- In-memory caches are performance optimizations only and MUST NOT be treated as authoritative permission state.
- If cache state and on-chain token state disagree, the wallet MUST use on-chain token state.
- Revocation, renewal, or token spend events that change permission state MUST invalidate affected cache entries immediately.
- Internal function names, callback names, and class names in this document are illustrative unless explicitly defined as protocol surface.

---

## 4. Permission Types

### 4.1 Protocol Permissions

Protocol permissions control an application's ability to interact with named protocols for cryptographic and data operations.

#### Scope

A protocol permission is scoped by two fields:

- **`protocolID`**: A tuple of `[securityLevel, protocolName]`
  - `securityLevel` - integer, `1` or `2`
  - `protocolName` - string identifier for the protocol
- **`counterparty`**: `'self'`, `'anyone'`, or a compressed public key identifying the other party. Empty string is invalid.
  - For **Level 2**, `counterparty` is REQUIRED and permission scope is per-originator + per-counterparty.
  - For **Level 1**, `counterparty` is application-scoped and SHOULD be omitted in manifest declarations.

#### Security Levels

- **Level 0**: Open usage - no permission check is required.
- **Level 1**: The application itself is the implicit counterparty. Protocol keys are derived per-originator. No counterparty prompt is required. Once granted for an originator, the permission applies across counterparties for that originator. The wallet SHOULD present the scope as application-only (e.g. "only with this app").
- **Level 2**: A specific external counterparty is involved. Protocol keys are derived per-counterparty. The wallet MUST identify the counterparty to the user by displaying the counterparty's compressed public key, and a PACT relationship may be required (see Section 5). The wallet SHOULD present the scope as application-and-counterparty (e.g. "only with this app and counterparty").

#### Sub-Operations

The wallet MAY prompt separately depending on the cryptographic operation being performed:

| Configuration Flag | Operation |
|---|---|
| `seekProtocolPermissionsForSigning` | Signing data using the protocol |
| `seekProtocolPermissionsForEncrypting` | Encrypting data using the protocol |
| `seekProtocolPermissionsForHMAC` | HMAC computation using the protocol |

#### Usage Types

When the wallet checks a protocol permission, it records the **usage type** that triggered the check:

`'signing'` | `'encrypting'` | `'hmac'` | `'publicKey'` | `'identityKey'` | `'linkageRevelation'` | `'generic'`

This allows the wallet to apply the relevant configuration flag (e.g. `seekProtocolPermissionsForSigning`) and to provide context in the user prompt.
Usage type context does not change protocol permission scope on-chain; scope is determined by the token fields in Section 7.2.

#### Grant Options

Protocol permission grants are binary (grant or deny). There are no amount limits or ephemeral flags. Wallets SHOULD issue protocol grants as non-expiring (`expiry = 0`). If an implementation supports finite expiry values, it SHOULD require explicit user or administrator intent, because routine expiry creates repeated renewal prompts and degraded UX.

#### Request Structure

```
{
  type: 'protocol'
  requestID: string
  originator: string
  protocolID: [securityLevel: number, protocolName: string]
  counterparty?: string       // Required for Level 2, optional for Level 1 (defaults to 'self')
  privileged?: boolean        // Whether the operation requires elevated privilege
  usageType?: string          // What triggered the check (signing, encrypting, etc.)
  reason?: string
  renewal?: boolean
  previousToken?: PermissionToken   // Present on renewals
}
```

---

### 4.2 Spending Permissions

Spending permissions control an application's ability to spend funds (satoshis) on behalf of the user. These are **high risk** and require explicit, informed user consent.

#### Scope

A spending permission is scoped by:

- **`satoshis`**: The amount being requested for the current transaction.
- **`lineItems`** (optional): An itemized breakdown, where each item has `{ satoshis, description }`.

#### Sub-Operations

Spending requests fall into distinct modes:

| Mode | Description |
|------|-------------|
| **Create spending limit** | Establishes a new recurring authorization for an originator |
| **Increase spending limit** | Raises an existing authorization ceiling |
| **Single transaction** | One-time spending request (`renewal: false`) |
| **Spending check-in** | Renewal of a previously authorized spending flow (`renewal: true`) |

#### Grant Options

Spending permissions support richer grant options than other permission types:

- **Ephemeral grant**: `ephemeral: true` - authorizes a single transaction only; not persisted as a standing limit. The wallet SHOULD present this as a one-time "Spend" action.
- **Amount limit**: `amount` - sets the authorized satoshi ceiling as a standing monthly authorization. The wallet tracks cumulative spending against this limit. The wallet SHOULD present this as "Allow up to N satoshis".
- **Denial**: The user declines the transaction entirely.

The wallet SHOULD present spending prompts with three choices:
1. **Deny** - reject the transaction
2. **Allow up to N satoshis** - create a standing monthly spending authorization (persisted as a DSAP token)
3. **Spend** - approve this single transaction only (ephemeral, no token created)

The wallet tracks:
- `transactionAmount` - the current request amount
- `totalPastSpending` - cumulative spending by this originator
- `amountPreviouslyAuthorized` - the existing limit (if any)
- `authorizationAmount` - the new limit being requested

#### Prompt Presentation

The spending prompt SHOULD display an itemized breakdown when `lineItems` are provided. Each line item shows a description and satoshi amount. The wallet SHOULD include the network fee as a separate line item and display a total. This allows the user to understand exactly what they are paying for before approving.

#### Monthly Tracking

Spending authorization tokens do **not** have a time-based expiry (expiry is always `0`). Instead, spending is tracked on a **calendar month** basis. The wallet calculates how much the originator has spent in the current month and compares it against the authorized limit.

#### Request Structure

```
{
  type: 'spending'
  requestID: string
  originator: string
  reason?: string
  renewal?: boolean
  spending: {
    satoshis: number
    lineItems?: Array<{
      type: 'input' | 'output' | 'fee'
      description: string
      satoshis: number
    }>
  }
}
```
---

### 4.3 Basket Permissions

Basket permissions control an application's ability to interact with named data baskets - structured, wallet-managed collections of spendable outputs.

#### Scope

A basket permission is scoped by:

- **`basket`**: The basket identifier string.

Basket permissions are granted per basket name. Granting access to one basket does **not** imply access to any other.

#### Sub-Operations

The wallet MAY prompt separately for each basket operation:

| Configuration Flag | Operation |
|---|---|
| `seekBasketInsertionPermissions` | Inserting items into the basket |
| `seekBasketListingPermissions` | Listing / viewing basket contents |
| `seekBasketRemovalPermissions` | Removing items from the basket |

#### Grant Options

Basket permission grants are binary (grant or deny). There are no amount limits or ephemeral flags.

#### Request Structure

```
{
  requestID: string
  basket?: string
  originator: string
  reason?: string
  renewal?: boolean
}
```

---

### 4.4 Certificate Permissions

Certificate permissions control an application's ability to interact with identity certificates - structured attestations issued by certifiers.

#### Scope

A certificate permission is scoped by:

- **`type`** (`certType`): The certificate type identifier string.
- **`verifierPublicKey`** (`verifier`): The compressed public key of the entity that will verify/receive the certificate data.
- **`fields`**: A record of specific certificate fields being requested. This enables **selective disclosure** - the application requests only the fields it needs, not the entire certificate.

#### Sub-Operations

Certificate operations use **two different permission mechanisms**:

| Operation | Permission Mechanism | Token Type | Config Flag |
|---|---|---|---|
| `proveCertificate` (disclosure) | Certificate access check | DCAP token (field-level) | `seekCertificateDisclosurePermissions` |
| `acquireCertificate` | Protocol permission check | DPACP token | `seekCertificateAcquisitionPermissions` |
| `listCertificates` | Protocol permission check | DPACP token | `seekCertificateListingPermissions` |
| `relinquishCertificate` | Protocol permission check | DPACP token | `seekCertificateRelinquishmentPermissions` |

Only **disclosure** (`proveCertificate`) uses the DCAP certificate-access token system with `certType`, `verifier`, and field-level matching. The other three operations are gated by **protocol-level** permission tokens, with the certificate type baked into the protocol name (e.g. `[1, "certificate acquisition <type>"]`). This means acquisition, listing, and relinquishment do not have field-level granularity.

#### Field Matching

When looking up an existing DCAP token for a disclosure request, field matching uses **subset semantics**: the requested fields MUST be a subset of the token's granted fields. A token granting `["name", "email"]` satisfies a request for `["name"]`, but a token granting `["name"]` does NOT satisfy a request for `["name", "email"]`.

Both `certType` and `verifierPublicKey` MUST match exactly (strict equality). There is no partial or fuzzy matching.

Note: The grouped manifest inclusion check (Section 6.3) uses **exact set equality** for fields - both the manifest entry and the request must have the same field set. This is stricter than the token lookup's subset semantics.

#### Grant Options

Certificate permission grants are binary (grant or deny), but the wallet presents field-level granularity - the user sees which specific fields are being requested.

#### Request Structure

```
{
  requestID: string
  certificate?: {
    certType?: string
    fields?: Record<string, any>
    verifier?: string
  }
  originator: string
  reason?: string
  renewal?: boolean
}
```

---

## 5. Counterparty Trust (PACT)

### 5.1 Definition

PACT (**Protocol Agnostic Counterparty Trust**) is a trust mechanism that governs whether the wallet user trusts a specific external counterparty for Level 2 protocol interactions within a specific application.

When an application involves peer-to-peer interactions - encrypted messaging, collaborative editing, trading, or any protocol where the user's cryptographic keys are used in relation to another person - the wallet needs to answer a question that group permissions alone cannot: **"Do I trust this particular person, through this particular app?"**

PACT provides that answer. It is a separate trust layer from group permissions, and it is established per originator + counterparty pair. A PACT granted for a counterparty through one application does **not** carry over to another application.

Applications declare their PACT requirements in the manifest's `metanet.counterpartyPermissions` section. This tells the wallet which Level 2 protocols are part of the peer interaction, so they can all be presented in a single trust prompt when a new counterparty is encountered - rather than prompting one protocol at a time.

---

### 5.2 Purpose

PACT addresses a fundamental gap in the permission model: group permissions answer "do I trust this app?", but they do not answer "do I trust this person through this app?" For applications with peer interactions, both questions must be answered.

PACT exists to:
- **Gate counterparty-specific interactions** - ensure a counterparty is explicitly trusted before Level 2 protocol permissions are granted for them
- **Separate app trust from peer trust** - a user may trust the app but not every counterparty the app introduces
- **Bundle peer protocol grants** - present all Level 2 protocols declared in `metanet.counterpartyPermissions` for a given counterparty in a single prompt, rather than prompting one-by-one as each protocol is used
- **Scope trust narrowly** - PACT is scoped to the originator + counterparty pair, preventing one app's trust decisions from affecting another app

---

### 5.3 Scope: Level 2 Only

PACT applies **exclusively** to Level 2 protocols. Level 1 protocols do not involve an external counterparty and therefore do not require PACT.

A PACT request contains:

```
{
  requestID: string
  originator: string              // The app through which the interaction occurs
  counterparty: string            // Compressed public key of the external entity
  counterpartyLabel?: string      // Optional display name
  permissions: {
    description?: string
    protocols: Array<{
      protocolName: string          // Level 2 protocol name
      description: string
    }>
  }
}
```

Wallets SHOULD present this to the user as: "This person (counterparty) wants to interact with you through this app (originator) using these protocols."

---

### 5.4 Separation from Group Permissions

Key distinctions:

| Aspect | Group Permissions | PACT |
|--------|------------------|------|
| Governs | Application -> Wallet | Counterparty -> User (via application) |
| Scoped to | Originator domain | Originator domain + Counterparty public key |
| Applies to | All four permission types | Level 2 protocols only |
| Prompted when | App attempts a wallet operation | App involves an untrusted counterparty |
| Declared in manifest | `metanet.groupPermissions` | `metanet.counterpartyPermissions` |

An operation MAY require both:
- A granted group permission (e.g. protocol access for the originator)
- An established PACT (trust for the specific counterparty)

---

### 5.5 Manifest-Driven Routing

When a permission request arrives, the wallet checks the originator's manifest and **routes the request based on its type**. The reference flow in Section 6.2 uses a deterministic strategy order (PACT -> peer-grouped -> grouped -> individual):

- If the request is a **Level 2 protocol** with a specific counterparty, and the manifest declares `counterpartyPermissions` covering that protocol -> the wallet checks for an established PACT and, if missing, triggers a **PACT prompt**.

- If the request is covered by the manifest's `groupPermissions` (any of the four permission types) -> the wallet filters out already-granted permissions and triggers a **grouped permission prompt**.

- If the request is a Level 2 protocol that appears in `groupPermissions` and shares a counterparty with other Level 2 protocols -> the wallet MAY present a **peer-grouped prompt** (all Level 2 protocols for that peer at once).

- If the request is not covered by any manifest declaration, or if the manifest is unavailable -> the wallet triggers an **individual permission prompt** for the specific permission type.

The routing is determined by the nature of each incoming request and what the manifest declares.

---

### 5.6 PACT Lifecycle

Compliant wallets MUST implement the following PACT lifecycle behavior:

PACT is not an in-memory-only permission. A granted PACT is represented by on-chain Level 2 protocol permission tokens scoped to the originator + counterparty pair.

#### Establishing a PACT

A PACT request flow triggers only when **all** of the following conditions are met:

1. `seekGroupedPermission` configuration is `true`
2. Counterparty trust prompting is enabled by the wallet
3. The request is for a **protocol** permission (not basket, certificate, or spending)
4. The request is **not** privileged
5. The protocol is **Level 2**
6. The counterparty is a specific 66-character hex public key (not `'self'` or `'anyone'`)
7. No PACT is already established for this originator + counterparty

If all conditions pass, the wallet:
1. Fetches the manifest's `counterpartyPermissions` for the originator.
2. Computes the relevant declared Level 2 protocol set for this originator + counterparty context.
3. Checks which of those protocols already have valid tokens.
4. Presents only missing protocols to the user in a PACT prompt.
5. On grant, creates on-chain protocol permission tokens for each approved protocol.
6. Ensures subsequent checks observe the newly granted state consistently.

#### Checking if a PACT Exists

For PACT evaluation, define the **relevant protocol set** as the Level 2 protocols from `counterpartyPermissions` that apply to the current originator + counterparty context. PACT is established only when every protocol in this set has a valid, unexpired token.

The wallet checks in this order:

1. If counterparty is `'self'` or `'anyone'` -> always `true`.
2. If the manifest has no `counterpartyPermissions` -> `true` (no PACT needed). This means applications that do not declare `counterpartyPermissions` will never trigger a PACT prompt - Level 2 protocol requests will fall through to individual or grouped permission prompts instead.
3. Evaluate the full relevant protocol set against canonical permission state (Section 3.4). If all protocols in the set are valid -> `true`.
4. Otherwise -> `false`.

#### Concurrent PACT Requests

If multiple requests simultaneously require establishing a PACT for the same originator + counterparty pair, wallets SHOULD coalesce them into a single user decision and MUST apply the resulting grant/denial outcome consistently to all waiting callers.

---

### 5.7 Whitelisted Counterparties

The wallet MAY define a set of **whitelisted counterparties** - known entities that are pre-authorized for specific protocols without requiring a user prompt.

Each entry maps a compressed public key to an array of protocol names the counterparty is pre-authorized for:

```
whitelistedCounterparties: {
  "<publicKey>": ["protocol-name-1", "protocol-name-2"]
}
```

Whitelist matching is **case-insensitive** for both public key and protocol name. Counterparties `'self'` and `'anyone'` are never checked against the whitelist.

This is used for infrastructure counterparties (e.g. message relay servers, payment processors) that the wallet vendor has pre-vetted.

---

### 5.8 Trust Settings

The wallet maintains user-configurable trust settings:

- **Trusted Certifiers**: A list of entities the user trusts, each with:
  - `identityKey` - compressed public key
  - `trust` - score from 1 to 10
  - `name`, `note`, `icon` - metadata (validated per BRC-68, see Section 3.2)

- **Trust Threshold**: A global threshold (0 to total trust points). Used during registry resolution to determine which registry operators are consulted for protocol, certificate, and basket definitions.

Trusted certifiers can be added by:
1. **Domain import** - fetching `metanet.trust` from an entity's manifest (BRC-68)
2. **Manual entry** - directly providing name, icon, and public key

New certifiers default to a trust score of 5.

---

## 6. Permission Request Flow

### 6.1 Permission Triggering

Permissions are checked **at runtime** when an application calls a wallet API method. Wallets MUST enforce permission checks before executing protected operations.

Applications MAY additionally declare their permissions upfront in the manifest's `metanet.groupPermissions` (see Section 3.2). When present, the wallet uses these declarations to **batch** permission prompts into a single grouped request on first interaction, reducing the number of individual prompts.

### 6.2 High-Level Flow

For each wallet API call from an originator:

1. The wallet normalizes the originator domain.
2. If the originator is the **admin originator**, the call is allowed unconditionally.
3. If the protocol/basket/label is **admin-reserved** (starts with `admin` or `p `), the call is rejected for non-admin originators.
4. The wallet checks the relevant **configuration flag** (e.g. `seekProtocolPermissionsForSigning`). If the flag is `false`, the call is allowed without a permission check.
5. If the counterparty + protocol is **whitelisted**, the call is allowed without a prompt.
6. The wallet MAY consult local transient state as an optimization, but MUST NOT allow a request unless the result is equivalent to canonical permission state (Section 3.4).
7. The wallet looks up an **on-chain permission token** in the relevant admin basket.
8. If a valid, unexpired token is found -> the call is allowed.
9. If an expired token is found -> the wallet triggers a **renewal** flow (`renewal: true`, with the old token attached).
10. If no token is found -> the wallet runs a permission resolution pipeline that attempts four strategies in order:
    - **Step 1**: PACT (Section 5.6) - Level 2 protocol with specific counterparty and manifest `counterpartyPermissions`.
    - **Step 2**: Peer-grouped (Section 6.4) - Level 2 protocol, groups all Level 2 protocols for the same counterparty from the manifest.
    - **Step 3**: Grouped (Section 6.3) - bundles all ungranted manifest `groupPermissions` into one prompt.
    - **Step 4**: Individual - type-specific prompt as fallback.
    Any strategy that does not handle the request falls through to the next strategy. The first definitive decision (grant or deny) is used.
11. User approves or denies. On grant, an on-chain token is created (unless ephemeral). On denial, the call throws with error code `ERR_PERMISSION_DENIED`.

### 6.3 Grouped Permission Requests

When an application declares `metanet.groupPermissions` in its manifest, the wallet uses this to present a **grouped permission request** - a single prompt containing all the permissions the application needs.

#### Trigger Conditions

The grouped prompt fires only when **all** of the following conditions are met:

1. **`seekGroupedPermission` is enabled** in the wallet configuration.
2. **The manifest is available** and contains a `metanet.groupPermissions` object.
3. **The current request is included** in the manifest's group permissions (see inclusion rules below).
4. **At least one declared permission is not yet granted.** The wallet checks each manifest-declared permission against existing on-chain tokens. If every permission is already granted, the grouped prompt is skipped.

If any condition fails, the grouped flow is skipped and the request proceeds to the individual prompt path.

#### Inclusion Rules

The wallet determines whether a request is "included" in the manifest's group permissions based on the request type:

- **Protocol**: The request's `protocolID` must exactly match a manifest entry. For **Level 2**, manifest `counterparty` is REQUIRED and MUST exactly match the request counterparty. For **Level 1**, matching is by `protocolID` (counterparty is application-scoped). Empty-string counterparty values are invalid. **Privileged** protocol requests are never included in grouped flows.
- **Basket**: The request's basket name must exactly match a manifest entry.
- **Certificate**: The request's `certType`, `verifierPublicKey`, and `fields` must all match a manifest entry. Field matching uses **exact set equality** (both sets must have the same elements). **Privileged** certificate requests are never included.
- **Spending**: Any spending request matches if the manifest declares a `spendingAuthorization` (regardless of amount).

#### Grouped Request Contents

A grouped request bundles:
- Protocol permissions (zero or more)
- Basket access (zero or more)
- Certificate access (zero or more)
- Spending authorization (zero or one)

The user can selectively approve individual items within the group. After the grouped prompt completes, the wallet re-checks whether the specific triggering permission was granted. If not (e.g. the user denied that particular item), the request falls through to an individual prompt.

#### Serialization

Only **one grouped permission flow** per originator may be active at a time. Concurrent requests for the same originator MUST wait for the active flow to complete. After waiting, each request MUST re-check whether its triggering permission was already satisfied before starting a new grouped prompt.

### 6.4 Peer-Grouped Requests

Peer-grouped requests are a specialized form of grouped request. They are tried **before** the full grouped flow (Step 3 in Section 6.2) and **after** the PACT flow (Step 1 in Section 6.2).

#### Trigger Conditions

A peer-grouped flow fires when **all** of:

1. `seekGroupedPermission` is enabled.
2. Grouped prompt handling is enabled by the wallet.
3. The current request is for a **protocol** permission.
4. The protocol is **Level 2**.

The wallet then:
1. Fetches the manifest's `groupPermissions`.
2. Filters to Level 2 protocol entries where `counterparty` is present and exactly matches the current request's counterparty.
3. Checks if the current request's `protocolID` is among them.
4. Filters out already-granted permissions.
5. If any remain, presents them as a peer-grouped prompt.

#### Characteristics

A peer-grouped prompt contains **only** Level 2 protocol permissions for a **single** counterparty - no basket, certificate, or spending items. This represents a focused trust decision: "grant this counterparty access to these protocols through this app."

If the peer-grouped flow does not apply or does not satisfy the request, it falls through to the full grouped flow (Step 3).

### 6.5 Permission Seeking Configuration

The wallet's prompting behavior is controlled by a set of configuration flags. Each flag determines whether the wallet SHOULD prompt the user for a specific operation type:

**Protocol Operations:**
| Flag | Default | Description |
|------|---------|-------------|
| `seekProtocolPermissionsForSigning` | `true` | Prompt when signing via a protocol |
| `seekProtocolPermissionsForEncrypting` | `true` | Prompt when encrypting via a protocol |
| `seekProtocolPermissionsForHMAC` | `false` | Prompt when computing HMAC via a protocol |

**Basket Operations:**
| Flag | Default | Description |
|------|---------|-------------|
| `seekBasketInsertionPermissions` | `true` | Prompt when inserting into a basket |
| `seekBasketListingPermissions` | `true` | Prompt when listing basket contents |
| `seekBasketRemovalPermissions` | `true` | Prompt when removing from a basket |

**Certificate Operations:**
| Flag | Default | Description |
|------|---------|-------------|
| `seekCertificateAcquisitionPermissions` | `true` | Prompt when acquiring certificates |
| `seekCertificateDisclosurePermissions` | `true` | Prompt when disclosing certificate fields |
| `seekCertificateRelinquishmentPermissions` | `true` | Prompt when relinquishing certificates |
| `seekCertificateListingPermissions` | `true` | Prompt when listing certificates |

**Identity & Key Operations:**
| Flag | Default | Description |
|------|---------|-------------|
| `seekPermissionsForIdentityKeyRevelation` | `true` | Prompt when revealing the user's identity key |
| `seekPermissionsForIdentityResolution` | `true` | Prompt when resolving identity information |
| `seekPermissionsForKeyLinkageRevelation` | `true` | Prompt when revealing key linkage |
| `seekPermissionsForPublicKeyRevelation` | `true` | Prompt when revealing a public key |

**Action & Spending:**
| Flag | Default | Description |
|------|---------|-------------|
| `seekPermissionWhenApplyingActionLabels` | `true` | Prompt when applying action labels |
| `seekPermissionWhenListingActionsByLabel` | `true` | Prompt when listing actions by label |
| `seekSpendingPermissions` | `true` | Prompt for spending authorization |

**Grouped Permissions:**
| Flag | Default | Description |
|------|---------|-------------|
| `seekGroupedPermission` | `true` | Enable grouped permission requests |
| `differentiatePrivilegedOperations` | `true` | Distinguish between privileged and non-privileged operations |

---

## 7. Permission Tokens (On-Chain Persistence)

Permission grants are persisted as **on-chain PushDrop outputs** stored in admin baskets within the user's wallet. This provides a tamper-evident, user-owned record of all granted permissions.

### 7.1 Token Storage

Each permission type has a dedicated admin basket:

| Type | Acronym | Admin Basket Name |
|------|---------|-------------------|
| Protocol | DPACP | `admin protocol-permission` |
| Basket | DBAP | `admin basket-access` |
| Certificate | DCAP | `admin certificate-access` |
| Spending | DSAP | `admin spending-authorization` |

Tokens are encoded as PushDrop outputs using encryption protocol `[2, 'admin permission token encryption']`, key ID `'1'`, and counterparty `'self'`. All fields within the token are **encrypted** - an observer inspecting the blockchain cannot determine which protocols are authorized, the expiry times, or the originator domains.

### 7.2 Token Fields

Each token type stores a different set of encrypted fields:

**DPACP (Protocol):** 6 fields
| # | Field | Description |
|---|-------|-------------|
| 0 | originator | Normalized domain |
| 1 | expiry | UNIX epoch seconds (0 = never) |
| 2 | privileged | `'true'` or `'false'` |
| 3 | securityLevel | `1` or `2` |
| 4 | protocolName | Protocol identifier string |
| 5 | counterparty | `'self'`, `'anyone'`, or public key |

DPACP tokens MUST NOT be created for Level 0 protocols, because Level 0 is open usage and does not require permission.

**DBAP (Basket):** 3 fields
| # | Field | Description |
|---|-------|-------------|
| 0 | originator | Normalized domain |
| 1 | expiry | UNIX epoch seconds (0 = never) |
| 2 | basketName | Basket identifier string |

**DCAP (Certificate):** 6 fields
| # | Field | Description |
|---|-------|-------------|
| 0 | originator | Normalized domain |
| 1 | expiry | UNIX epoch seconds (0 = never) |
| 2 | privileged | `'true'` or `'false'` |
| 3 | certType | Certificate type identifier |
| 4 | fields | JSON-encoded array of authorized field names |
| 5 | verifier | Verifier public key |

**DSAP (Spending):** 2 fields
| # | Field | Description |
|---|-------|-------------|
| 0 | originator | Normalized domain |
| 1 | authorizedAmount | Monthly satoshi limit |

Note: DSAP tokens do not have an expiry field. Spending is tracked by calendar month.

### 7.3 Expiry

- Tokens with `expiry === 0` never expire.
- Tokens with `expiry > 0` are compared against the current UNIX epoch time in seconds. If `expiry < now`, the token is expired.
- When an expired token is found, the wallet triggers a **renewal** flow rather than a new permission request.
- Wallets SHOULD set `expiry = 0` for user-granted permissions, because users can revoke permissions at any time and non-zero expiry creates avoidable renewal friction.
- If a finite expiry is supported, it SHOULD be an explicit opt-in policy choice rather than the default.
- DSAP (spending) tokens always have `expiry = 0` - spending limits are enforced on a calendar month basis instead.

### 7.4 Granting

When the user approves a permission request:

1. Resolves all pending requests (multiple callers waiting on the same permission are all unblocked).
2. Unless this is an ephemeral request, creates or renews the corresponding on-chain permission token.
3. Updates any transient local state so subsequent checks observe the new permission state consistently.

Grant variants:

- **Individual grant** - applies to one permission request.
- **Grouped grant** - applies to the approved subset from a grouped permission request.
- **PACT grant** - creates protocol tokens for each approved Level 2 protocol in the PACT prompt.

**Ephemeral grants**: When `ephemeral: true`, no on-chain token is created. The permission is a one-time in-memory authorization. The caller's request is allowed, but no persistent record is kept. Used primarily for one-off spending approvals.

### 7.5 Denial

When the user denies a permission:

- All pending application requests for the resource are **rejected** with an error: `'The user has denied the request for permission.'` (error code: `ERR_PERMISSION_DENIED`).
- The wallet MUST enforce denial deterministically - it MUST NOT silently fall back or degrade.

Applications SHOULD treat denied permissions as expected states, not errors.

### 7.6 Revocation

Granted permissions MUST be revokable by the user at any time through the wallet's user interface. Revocation MUST **spend** the on-chain token output with no replacement - the transaction consumes the token UTXO and produces no new permission output, leaving nothing in the respective admin basket.

The wallet supports:

- **Individual revocation** - spends and invalidates a single token.
- **Batch revocation** - revokes multiple tokens.
- **Full originator revocation** - revokes all tokens for an application, optionally filtered by type.

Revoked permissions MUST be enforced immediately. The application will be prompted again on next use.

### 7.7 Renewal

When the wallet finds an expired token during a permission check, it triggers a renewal flow:

1. The old token is attached to the request as `previousToken`.
2. The request is flagged with `renewal: true`.
3. On grant, the wallet spends the old token and creates a new token with the updated expiry.
4. If multiple old tokens exist for the same permission parameters, they are first **coalesced** into a single token to avoid UTXO bloat.

### 7.8 Caching

Wallets MAY use local caching and memoization to reduce repeated lookups.

Caching rules:

- Local cache state MUST NOT be treated as authoritative permission state.
- An allow/deny decision for a protected operation MUST be equivalent to evaluation of canonical permission state (Section 3.4).
- Cache invalidation MUST occur when grant, renewal, revocation, or token-spend events change permission state.
- If the wallet cannot prove cached data is still valid, it MUST re-evaluate against canonical permission state before allowing.

### 7.9 Request Deduplication

When multiple API calls from the same originator concurrently require the same permission scope, wallets SHOULD deduplicate to a single user-facing decision.

For deduplication, "same permission scope" means requests that map to the same token fields in Section 7.2:

- Protocol: same `originator`, `privileged`, `protocolID`, and `counterparty` (usage type differences do not change scope)
- Basket: same `originator` and `basketName`
- Certificate: same `originator`, `privileged`, `certType`, `fields`, and `verifier`
- Spending: same `originator` and requested spending scope

Concurrent handling requirements:

1. Callers waiting on the same scope MUST all receive outcomes consistent with the final permission decision for that scope.
2. After any concurrent flow completes (individual, grouped, peer-grouped, or PACT), each waiting caller MUST re-check canonical permission state before triggering an additional prompt.
3. Deduplication strategy is implementation-defined, but it MUST NOT cause over-granting, silent allow on denial, or scope broadening.

---

## 8. Manifest Guidance

Applications SHOULD:
- Serve a valid W3C-compliant `manifest.json` at their domain root
- Include a human-readable `name` and `short_name` field
- Include an `icons` array with at least one icon for visual identification in wallet UI
- Declare `metanet.groupPermissions` listing all permissions the application requires - this enables a single upfront prompt instead of repeated individual prompts
- Declare `metanet.counterpartyPermissions` if the application involves Level 2 peer interactions

Applications MAY:
- Include a `metanet.trust` object (BRC-68) if the application operator is also a trust entity

Applications MUST NOT:
- Declare Level 1 protocols in `counterpartyPermissions` (they will be silently dropped)

Wallets SHOULD:
- Cache manifest data per originator with a reasonable freshness policy
- Display the manifest name in all permission prompts and dashboard views
- Fall back gracefully to the domain name if the manifest is unavailable or lacks a `name` field
- Deduplicate concurrent manifest fetches for the same originator

---

## 9. Security Considerations

- Permissions MUST never be implicitly granted.
- All permission decisions MUST be user-driven.
- Revoked permissions MUST be enforced immediately.
- Permission data MUST be isolated per originator.
- Manifest fetches MUST be restricted to HTTPS (except localhost for development).
- Manifest proxy MUST validate URL path - only `/manifest.json` paths are permitted.
- Whitelisted counterparties SHOULD be limited to infrastructure entities pre-vetted by the wallet vendor. The whitelist MUST NOT be user-extensible without explicit configuration.
- Trusted certifier public keys MUST conform to compressed public key format (`/^(02|03)[a-fA-F0-9]{64}$/`).
- On-chain permission token fields MUST be encrypted so that only the wallet owner can read them.
- Protocol and basket names starting with `admin` or `p ` are reserved and MUST NOT be accessible to non-admin originators.
- The basket name `default` is reserved for internal wallet operations.
- PACT counterparties MUST be validated as 66-character hexadecimal strings (compressed public key format).

---

## Implementations (Informative)

> This section captures implementation-specific details. These are informative, not normative.

**Wallet-Toolbox (`@bsv/wallet-toolbox-client`):**
- `WalletPermissionsManager` wraps the BRC-100 `WalletInterface`, intercepting every method call. It is the enforcement layer.
- Permission tokens are created, renewed, and revoked using standard BRC-100 `createAction` / `signAction` flows.
- Transaction descriptions for permission operations are optionally encrypted using `[2, 'admin metadata encryption']` when `encryptWalletMetadata` is enabled.
- The manager supports **P-modules** via the `PermissionsModule` interface (see below).

**P-Modules (`PermissionsModule` - BRC-98/99/111):**

P-modules are an extensibility mechanism that allows wallet consumers to add custom permission handling for P-prefix baskets, protocols, and labels.

*Interface:* A module MUST implement two methods:
- **`onRequest({ method, args, originator })`** -> `{ args }` - transforms the request before it reaches the underlying wallet. May enforce permissions, throw errors, or modify arguments.
- **`onResponse(result, { method, originator })`** -> `result` - transforms the wallet response before returning to the caller.

*Registration:* Modules are registered via the `permissionModules` config field - a `Record<string, PermissionsModule>` keyed by scheme ID (e.g. `{ "btms": new BtmsModule() }`). If a P-prefix name references an unregistered scheme ID, the wallet throws immediately.

*Detection and routing:* Any basket name, protocol name, or label starting with `"p "` triggers the P-module system. The scheme ID is extracted as the second token (e.g. `"p btms token123"` -> scheme ID `"btms"`).

*P-label format (BRC-111):* Labels MUST follow the format `p <moduleId> <payload>` where:
- `moduleId` is at least 1 character, no spaces
- A single space separates `moduleId` from `payload`
- `payload` is at least 1 character and MUST NOT start with a space

*Scope:* P-modules handle baskets (`listOutputs`, `relinquishOutput`, `createAction`, `internalizeAction`), protocols (`encrypt`, `decrypt`, `createHmac`, `verifyHmac`, `createSignature`, `verifySignature`, `getPublicKey`), and labels (`createAction`, `listActions`, `internalizeAction`).

*Bypass behavior:* P-module paths **completely bypass** the standard on-chain permission token system (DPACP/DBAP/DCAP/DSAP). The module's `onRequest` method is solely responsible for any authorization logic. Non-P baskets, protocols, and labels in the same operation still go through the standard permission checks.

*Chaining:* When multiple P-modules are involved in a single operation (e.g. `createAction` with baskets from one scheme and labels from another), `onRequest` calls are chained forward through all modules, and `onResponse` calls are chained in **reverse** order.

---

## References

This specification references or builds upon:

| BRC | Title | Relevance |
|-----|-------|-----------|
| [BRC-68](../peer-to-peer/0068.md) | Publishing Trust Anchor Details at an Internet Domain | `metanet.trust` manifest structure for trusted certifiers |
| [BRC-73](./0073.md) | Group Permissions for App Access | `GroupedPermissions` interface for batched permission requests |
| [BRC-98](./0098.md), [BRC-99](./0099.md) | P Protocols and P Baskets | Extensible permission modules for P-prefix schemes |
| [BRC-100](./0100.md) | Unified Wallet-to-Application Interface | Underlying wallet API that the permissions manager wraps |
| [BRC-111](./0111.md) | P Labels | Label format `p <moduleId> <payload>` for permission modules |

---

## Non-Goals

This document does not define:
- UI layout or copy
- Wallet-specific storage implementations
- Application UX strategies beyond enforcement expectations
- The full internal API surface of `WalletPermissionsManager`

---

## Backwards Compatibility (`babbage` -> `metanet`)

Prior versions of the wallet permissions system used a `babbage` namespace in the manifest instead of `metanet`. The previous format was:

```json
{
  "name": "My Application",
  "babbage": {
    "groupPermissions": { ... },
    "counterpartyPermissions": { ... },
    "trust": { ... }
  }
}
```

Compared to the `metanet` format defined by this specification, the legacy `babbage` format did not standardize:
- A versioned permissions namespace (`schemaVersion`)
- A W3C Web App Manifest-aligned structure for application metadata
- A normative compatibility model for consuming both legacy and current namespaces during migration

#### Migration Path

Applications SHOULD update their manifests to use the `metanet` namespace and W3C-compliant structure. The migration involves:

1. **Rename the namespace**: Change `"babbage"` to `"metanet"`.
2. **Add `schemaVersion`**: Add `"schemaVersion": 1` inside the `metanet` object.
3. **Add W3C fields**: Include standard manifest fields (`short_name`, `description`, `start_url`, `display`, `icons`) at the top level.
4. **Move trust data**: If using `babbage.trust`, rename to `metanet.trust` (structure is unchanged).

#### Wallet Compatibility

Wallets MUST support both namespaces during the transition period:

1. Check for `metanet` first. If present, use it.
2. If `metanet` is absent, fall back to `babbage` and treat it as equivalent to `metanet` without a `schemaVersion`.
3. Log a deprecation warning when a `babbage` namespace is encountered to encourage migration.

#### Timeline

The `babbage` namespace is **deprecated** as of this specification. Wallets SHOULD continue to support it for backwards compatibility until a future version removes support. Applications SHOULD migrate to `metanet` at their earliest convenience.

