# BRC-74: Unified Merkle Path Format

Darren Kellenschwiler (deggen@kschw.com), Deggen
Tone Engel (tone@kizmet.org), TonesNotes
Ty Everett (ty@projectbabbage.com)
Damian Orzepowski (damian.orzepowski@4chain.studio)

## Abstract

We propose a Compound Merkle Path format in both binary and JSON encoding optimized for transmission, storage, and ease of use in a Merkle Proof validation process.

## Copyright

This BRC is licensed under the Open BSV license.

## Motivation

Several formats have made their own improvements to the original format which was returned by a Bitcoin node via json-rpc method `getmerkleproof`.

Improvements include:
- [BRC-10](./0010.md) a TSC creation which was subsequently returned by the node's json-rpc method `getmerkleproof2`
- [BRC-11](./0011.md) removing the need for specifying targets, replacing with height to improve validation speed.
- [BRC-58](./0058.md) removal of all extraneous data to minimize data size.
- [BRC-61](./0061.md) introduction of a compound path encoding which allows representation of multiple paths within the same block.

The purpose of defining this new specification is to capture the incremental improvements under one spec which encapsulates the pros of each, and removes the cons. This new spec should allow:

- Inclusion of height makes lookup extremely fast while only adding maximum 9 bytes to the data size.
- Multiple paths can be expressed in the same data model.
- One format for everything, so that there is no need to convert from single to compound path.
- Size optimization allowing us to skip encoding of far right leaves when duplication of working hash would suffice.


## JSON Encoding


```json
{
  "height": 813706,
  "path": [ // Array index corresponds to the height within the Merkle tree, so we start with level 0 which is the txids themselves
    { // within each height there must be one or more hashes with their corresponding offsets { [hash]: offset }
      "3048": "304e737fdfcb017a1a322e78b067ecebb5e07b44f0a36ed1f01264d2014f7711", // txid at index 3048
      "3049": "d888711d588021e588984e8278a2decf927298173a06737066e43f3e75534e00",
      "3050": "98c9c5dd79a18f40837061d5e0395ffb52e700a2689e641d19f053fc9619445e", // txid at index 3050
      "3051": "*" // indicates an absence of a value at this position, and so a dup of working hash should be used in its place.
    },
    {
      "1524": "811ae75c80fecd27efff5ef272c2adf7edb6e535447f27a4087d23724f397106",
      "1525": "82520a4501a06061dd2386fb92fa5e9ceaed14747acc00edf34a6cecabcc2b26"
    },
    {
      "763": "*"
    },
    {
      "380": "858e41febe934b4cbc1cb80a1dc8e254cb1e69acff8e4f91ecdd779bcaefb393"
    },
    {
      "191": "*"
    },
    {
      "94": "f80263e813c644cd71bcc88126d0463df070e28f11023a00543c97b66e828158"
    },
    {
      "46": "f36f792fa2b42acfadfa043a946d4d7b6e5e1e2e0266f2cface575bbb82b7ae0"
    },
    {
      "22": "7d5051f0d4ceb7d2e27a49e448aedca2b3865283ceffe0b00b9c3017faca2081"
    },
    {
      "10": "43aeeb9b6a9e94a5a787fbf04380645e6fd955f8bf0630c24365f492ac592e50"
    },
    {
      "4": "45be5d16ac41430e3589a579ad780e5e42cf515381cc309b48d0f4648f9fcd1c"
    },
    {
      "3": "*"
    },
    {
      "0": "d40cb31af3ef53dd910f5ce15e9a1c20875c009a22d25eab32c11c7ece6487af"
    }
  ]
}
```

## Binary Encoding

The top level encoding specifies a block height and a tree height.

| Field                | Description                                                                            |        Size          |
|----------------------|----------------------------------------------------------------------------------------|----------------------|
| block height         | `VarInt` block height in which the transactions are encapsulated                       | 1-9 bytes            |
| tree height          | The height of the tree up to a max 64, specifies the height one below the root         | 1 byte               |

Thereafter the number of leaves at the top height is specified, and the leaves for this height follow. 

| Field                | Description                                                                            |        Size          |
|----------------------|----------------------------------------------------------------------------------------|----------------------|
| nLeaves              | `VarInt` number of leaves at this height                                               | nLeaves x 1-9 bytes  |
| leaves               | Each leaf encoded in the format below.                                                 | nLeaves x 1-9 bytes  |

Once all leaves at this height have been specified, an implied decrement of the height in the tree occurs and we specify the number of leaves in the next level down, and so on until we have specified the leaves at level 0 at which point we stop.  
  
Each leaf follows the format below:

| Field                | Description                                                                            |        Size          |
|----------------------|----------------------------------------------------------------------------------------|----------------------|
| offset               | `VarInt` offset from left hand side within tree                                        | 1-9 bytes            |
| data flag            | 01 indicates "a 32 byte hash follows" - 00 indicates "no data, duplicate working hash" | 1 byte               |
| leaf                 | Each leaf is a 32 byte hash                                                            | 32 bytes or skipped  |

## Example

### Hex
```
fdea0bfe8a6a0c000c
```

### Bytewise Breakdown
```javascript
fe8a6a0c00 // block height VarInt
0b // 1 byte tree height (eleven)
01 // nLeaves VarInt at level 11
00 // offset VarInt
01 // data follows
af8764ce7e1cc132ab5ed2229a005c87201c9a5ee15c0f91dd53eff31ab30cd4 // hash at 11th level of tree
01 // nLeaves VarInt at level 10
03 // offset VarInt
00 // no data follows
01 // nLeaves VarInt at level 9
04 // offset VarInt
01 // data follows
1ccd9f8f64f4d0489b30cc815351cf425e0e78ad79a589350e4341ac165dbe45 // hash at 9th level of tree
01 // nLeaves VarInt at level 8
0a // offset VarInt
01 // data follows
502e59ac92f46543c23006bff855d96f5e648043f0fb87a7a5949e6a9bebae43 // hash at 8th level of tree
01 // nLeaves VarInt at level 7
16 // offset VarInt (twenty two)
01 // data follows
8120cafa17309c0bb0e0ffce835286b3a2dcae48e4497ae2d2b7ced4f051507d // hash at 7th level of tree
01 // nLeaves VarInt at level 6
2e // offset VarInt (forty six)
01 // data follows
e07a2bb8bb75e5accff266022e1e5e6e7b4d6d943a04faadcf2ab4a22f796ff3 // hash at 6th level of tree
01 // nLeaves VarInt at level 5
5e // offset VarInt (ninty four)
01 // data follows
5881826eb6973c54003a02118fe270f03d46d02681c8bc71cd44c613e86302f8 // hash at 5th level of tree
```

## Calculating the Merkle Root from a Unified Compound Merkle Path

Let's start by dumping this format as hex into a Buffer and parsing it into an object with a Buffer Reader. Then we construct an object

```javascript
const { createHash } = require('crypto')

// Displaying hashes as hex strings in reverse byte order is a matter of convention with respect to txids. 
// The functions below handle the conversions such that when we "hash()" something, we are running sha256 - 
// digesting the reverse bytes of a hex string, and returning the reverse bytes encoded as a hex string.
const hexRevToBuf = (str) => Buffer.from(str, 'hex').reverse()
const bufRevToHex = (buf) => Buffer.from(buf.toString('hex'), 'hex').reverse().toString('hex')
const hash = (str) => bufRevToHex(createHash('sha256').update(createHash('sha256').update(hexRevToBuf(str)).digest()).digest())

function calculateMerkleRootFromUCMP(ucmp, txid) {
    // We need to determine the index of the txid.
    let index
    // The first path object contains the bottom leaves of the Merkle tree.
    for (let i in ucmp.path[0]) {
        // Whichever points to the txid is the index we're after.
        if (txid === ucmp.path[0][i]) index = Number(i)
    }
    if (!index) throw Error(`The CMP does not contain the txid: ${txid}`)
    // Calculate the root using the index as a way to determine which direction to concatenate.
    let workingHash = txid
    ucmp.path.map((leaves, height) => {
        const offset = index >> height ^ 1
        const leaf = leaves[offset]
        if (!leaf) throw Error(`We do not have a hash for this index at height: ${height}`)
        if (leaf === '*') {
            // if there is no data at this index, we are at the right hand side of the tree, and so we duplicate the working hash.
            workingHash = hash(workingHash + workingHash)
        } else if (offset % 2) {
            // if the offset is odd then we concatenate the leaf on the left. 
            //     H
            //   /  \
            //  L   W
            workingHash = hash(leaf + workingHash)
        } else {
            // if the offset is even then we concatenate the leaf on the right 
            //     H
            //   /  \
            //  W   L
            workingHash = hash(workingHash + leaf)
        }
    })
    return workingHash
}

calculateMerkleRootFromUCMP(ucmp, txid)
// txid '98c9c5dd79a18f40837061d5e0395ffb52e700a2689e641d19f053fc9619445e'
// Using the Unified Compound Merkle Proof json from the example in this document should yield the root: 
// '57aab6e6fb1b697174ffb64e062c4728f2ffd33ddcfa02a43b64d8cd29b483b4'
```
