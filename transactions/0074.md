# BRC-74: Unified Merkle Path Format

Darren Kellenschwiler (deggen@kschw.com), Deggen
Tone Engel (tone@kizmet.org), TonesNotes
Ty Everett (ty@projectbabbage.com)
Damian Orzepowski (damian.orzepowski@4chain.studio)

## Abstract

We propose a Compound Merkle Path format in both binary and JSON encoding optimized for transmission, storage, and ease of use in a Merkle Proof validation process.

## Copyright

This BRC is licensed under the Open BSV license.

## Motivation

Several formats have made their own improvements to the original format which was returned by a Bitcoin node via json-rpc method `getmerkleproof`.

Improvements include:
- [BRC-10](./0010.md) a TSC creation which was subsequently returned by the node's json-rpc method `getmerkleproof2`
- [BRC-11](./0011.md) removing the need for specifying targets, replacing with height to improve validation speed.
- [BRC-58](./0058.md) removal of all extraneous data to minimize data size.
- [BRC-61](./0061.md) introduction of a compound path encoding which allows representation of multiple paths within the same block.

The purpose of defining this new specification is to capture the incremental improvements under one spec which encapsulates the pros of each, and removes the cons. This new spec should allow:

- Inclusion of height makes lookup extremely fast while only adding maximum 9 bytes to the data size.
- Multiple paths can be expressed in the same data model.
- One format for everything, so that there is no need to convert from single to compound path.
- Size optimization allowing us to skip encoding of far right leaves when duplication of working hash would suffice.

## Specification

```json

{ 
  "index": 3050,
  "height": 813706,
  "path": [
    "*",
    "811ae75c80fecd27efff5ef272c2adf7edb6e535447f27a4087d23724f397106",
    "*",
    "858e41febe934b4cbc1cb80a1dc8e254cb1e69acff8e4f91ecdd779bcaefb393",
    "*",
    "f80263e813c644cd71bcc88126d0463df070e28f11023a00543c97b66e828158",
    "f36f792fa2b42acfadfa043a946d4d7b6e5e1e2e0266f2cface575bbb82b7ae0",
    "7d5051f0d4ceb7d2e27a49e448aedca2b3865283ceffe0b00b9c3017faca2081",
    "43aeeb9b6a9e94a5a787fbf04380645e6fd955f8bf0630c24365f492ac592e50",
    "45be5d16ac41430e3589a579ad780e5e42cf515381cc309b48d0f4648f9fcd1c",
    "*",
    "d40cb31af3ef53dd910f5ce15e9a1c20875c009a22d25eab32c11c7ece6487af"
  ]
}
```

Encoding in bytes we start with a VarInt for index, followed by nPath being the number of leaves to follow, followed by 32 byte leaves.


#### Data Types

| Field                | Description                                                                                                           |        Size          |
|----------------------|-----------------------------------------------------------------------------------------------------------------------|----------------------|
| index                | `VarInt` tx index number from within a block                                                                          | 1-9 bytes            |
| nLeaves              | number of leaves which follow, max 64                                                                                 | 1 byte               |
| leaf                 | Each leaf of the path is a 32 byte hash, but we prefix with a 00 to indicate a skip, or 01 to indicate a hash follows | 33 bytes x nLeaves   |

## Example

### Hex
```
88040c82025f47b31054e9ad52109ef25b00fd9aaae7153564619bab031d4112f56c3b6ea708d7b84a078179b53cf2cb2f0636162ffd60a96f81815564bbc6c073cdefac0f077fca2a10730400da62ebaebaba852bd5fc3fb7770e090a1919d9c8b41e81e396da7f63e3989a8bc9bdbefddf95c75da1eb3936944b6a55cf82d87034
```

### Bytewise Breakdown
```javascript
---- // index VarInt
0c // nLeaves
811ae75c80fecd27efff5ef272c2adf7edb6e535447f27a4087d23724f397106 // leaf
```

## Implementation

Let's start by dumping this format as hex into a Buffer and parsing it into an object with a Buffer Reader. Then we construct an object

```javascript
const { createHash } = require('crypto')
const hexRevToBuf = (str) => Buffer.from(str, 'hex').reverse()
const bufRevToHex = (buf) => Buffer.from(buf.toString('hex'), 'hex').reverse().toString('hex')
const hash = (str) => bufRevToHex(createHash('sha256').update(createHash('sha256').update(hexRevToBuf(str)).digest()).digest())

const merklePath = {
  txid: '98c9c5dd79a18f40837061d5e0395ffb52e700a2689e641d19f053fc9619445e',
  index: 3050,
  height: 813706,
  path: [
    '*',
    '811ae75c80fecd27efff5ef272c2adf7edb6e535447f27a4087d23724f397106',
    '*',
    '858e41febe934b4cbc1cb80a1dc8e254cb1e69acff8e4f91ecdd779bcaefb393',
    '*',
    'f80263e813c644cd71bcc88126d0463df070e28f11023a00543c97b66e828158',
    'f36f792fa2b42acfadfa043a946d4d7b6e5e1e2e0266f2cface575bbb82b7ae0',
    '7d5051f0d4ceb7d2e27a49e448aedca2b3865283ceffe0b00b9c3017faca2081',
    '43aeeb9b6a9e94a5a787fbf04380645e6fd955f8bf0630c24365f492ac592e50',
    '45be5d16ac41430e3589a579ad780e5e42cf515381cc309b48d0f4648f9fcd1c',
    '*',
    'd40cb31af3ef53dd910f5ce15e9a1c20875c009a22d25eab32c11c7ece6487af'
  ]
}

function calculateMerkleRoot({ txid, index, path }) {
  let workingHash = txid
  let leaf
  while (index > 0) {
    leaf = path.shift()
    if (leaf === '*') {
      workingHash = hash(workingHash + workingHash)
    } else if (index % 2) {
      workingHash = hash(workingHash + leaf)
    } else {
      workingHash = hash(leaf + workingHash)
    }
    index = Math.floor(index / 2)
  }
  return workingHash
}

console.log(calculateMerkleRoot(merklePath))
// '57aab6e6fb1b697174ffb64e062c4728f2ffd33ddcfa02a43b64d8cd29b483b4'
```
