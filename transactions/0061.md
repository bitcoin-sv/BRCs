# BRC-61: Background Evaluation Extended Format (BEEF) Transaction

## Abstract

We propose further extension to the existing Extended Format [BRC-30](./0030.md) to allow Simple Payment Verification (SPV). Specifically we aim to validate that all inputs to a transaction come from transactions which are already in a block which exists within the longest chain of work, and if not then the chain is followed backwards through history to arrive at a place where all inputs are as such.

## Copyright

This BRC is licensed under the Open BSV license.

## Motivation

There are currently two approaches to this in the wild. First is Extended Format [BRC-30](./0030.md) which incorporates the script and satoshis of the input for script evaluation and checking fee rates and the transfer amounts of a tx. The second is Tx Ancestry which is a TSC format which was created for use within DPP, this uses an array of rawtxs, merkle proofs, and Mapi responses to transport the data required for SPV. Mapi responses are essentially deprecated, so those should be discarded. The array of rawtxs makes some sense in that there are strange cases where the same rawtx has two outputs which are spent in different transactions, both within the ancestry of the tx we are validating. You don't want to have embedded a copy of the same proof twice, hence a hash map would make more sense than just including the merkle path bytes in the tx itself.

We want to unify theses standards into one idea which covers edge cases and optimizes for smallest format with the least amount of data while allowing counterparties to verify the tx to the fullest

## Specification

Raw Transaction format:

| Field           | Description                                          | Size                                             |
|-----------------|------------------------------------------------------|--------------------------------------------------|
| Version no      | currently 2                                          | 4 bytes                                          |
| In-counter      | positive integer VI = [[VarInt]]                     | 1 - 9 bytes                                      |
| list of inputs  | Transaction Input  Structure                         | <in-counter> qty with variable length per input  |
| Out-counter     | positive integer VI = [[VarInt]]                     | 1 - 9 bytes                                      |
| list of outputs | Transaction Output Structure                         | <out-counter> qty with variable length per output |
| nLocktime       | if non-zero and sequence numbers are < 0xFFFFFFFF: block height or timestamp when transaction is final | 4 bytes                                          |

BEEF adds a marker to the transaction format:

| Field            | Description                                                                                            | Size                                              |
|------------------|--------------------------------------------------------------------------------------------------------|---------------------------------------------------|
| Version no       | currently 2                                                                                            | 4 bytes                                           |
| **BEEF marker**  | **marker for Background Evaluation Extended Format**                                                   | **00000000BEEF**                                  |
| In-counter       | positive integer VI = [[VarInt]]                                                                       | 1 - 9 bytes                                       |
| list of inputs   | **BEEF** transaction Input Structure                                                        | <in-counter> qty with variable length per input   |
| Out-counter      | positive integer VI = [[VarInt]]                                                                       | 1 - 9 bytes                                       |
| list of outputs  | Transaction Output Structure                                                                           | <out-counter> qty with variable length per output |
| nLocktime        | if non-zero and sequence numbers are < 0xFFFFFFFF: block height or timestamp when transaction is final | 4 bytes                                           |

The BEEF marker allows a library that supports the format to recognize that it is dealing with a transaction in extended format, while a library that does not support extended format will read the transaction as having 0 inputs, 0 outputs and a future nLock time. This has been done to minimize the possible problems a legacy library will have when reading the extended format. It can in no way be recognized as a valid transaction.

The input structure is the only additional thing that is changed in the Extended Format. The current input structure looks like this:

| Field                     | Description                                                                                 | Size        |
|---------------------------|---------------------------------------------------------------------------------------------|-------------|
| Previous Transaction hash | TXID of the transaction the output was created in                                           | 32 bytes    |
| Previous Txout-index      | Index of the output (Non negative integer)                                                  | 4 bytes     |
| Txin-script length        | Non negative integer VI = VarInt                                                            | 1 - 9 bytes |
| Txin-script / scriptSig   | Script                                                                                      | many bytes  | 
| Sequence_no               | Used to iterate inputs inside a payment channel. Input is final when nSequence = 0xFFFFFFFF | 4 bytes     |

In BEEF, we extend the input structure to include satoshi amount, the previous locking script, index number which points to the particular path associated with the txid in the path array:

| Field                          | Description                                                                                 | Size             |
|--------------------------------|---------------------------------------------------------------------------------------------|------------------|
| Previous Transaction hash      | TXID of the transaction the output was created in                                           | 32 bytes         |
| Previous Txout-index           | Index of the output (Non negative integer)                                                  | 4 bytes          |
| Txin-script length             | VarInt Unlocking Script Length                                                              | 1 - 9 bytes      |
| Txin-script / scriptSig        | Unlocking Script                                                                            | many bytes       | 
| Sequence_no                    | Used to iterate inputs inside a payment channel. Input is final when nSequence = 0xFFFFFFFF | 4 bytes          |
| **UTXO satoshi amount**        | **Output value in satoshis of previous input - uint64le**                                   | **8 bytes**      |
| **UTXO locking script length** | **VarInt length of locking script OR 00 which indicates there is a "local anchor"**         | **1 - 9 bytes**  |
| **UTXO locking script**        | **Script**                                                                                  | **many bytes**   |
| **path pointer**               | **VarInt points to a particular path from the array**                                       | **1 - 9 bytes**  |

The overall structure starts with the paths of all txids corresponding to their place within the blockchain. Blockhashes are not included. Instead the validator is to calculate the merkle root and lookup thier own header store by that to verify the tx appears within the valid chain of blocks.

Path:

| Field                     | Description                                                                        |        Size          |
|---------------------------|------------------------------------------------------------------------------------|----------------------|
| index                     | Uint64le The index number of the txid within the block it was mined                | 8 bytes              |
| nLeaves                   | VarInt number of leaves which follow in the path                                   | 1-9 bytes            |
| leaf                      | Each leaf is a 32 byte hash                                                        | 32 bytes x nLeaves   |


### Local Anchor

When the VarInt following the satoshi amount of an input is "00" zero - this indicates that the input is has a local anchor. This means that the txid in the input points to a previous transactions which exists within the array of transactions in the data shared. For this reason, no further data is shared since this would be repeatition of early bytes. The process a validator would take is to at this point lookup the hashmap of validated previous transactions to determine whether to continue.

Order is important - we must ensure that we end with the tx being evaluated, and its inputs are above, and their inputs are above that. There may be a complex dependency tree above so we take a stack base approach as we add inputs from inputs, and run a unique filter on the txid set to ensure no repetion, and first mention is top of the stack. This will allow us to sequentially validate a stream of transactions as they come in without depending on data which hasn't arrived yet.

For the same reason, we have to start the stream with the paths of the transactions first, prior to any tx data.
This makes the overall structure look something like:

### Overall Structure of the Transmitted Data

```javascript
nPaths // paths first
index
nLeaves
leaves... // repeat for each path, then ancestry starting oldest first
nTransactions
BEEF transaction bytes...
// for example a tx with local anchor
  version
  00000000BEEF
  nInputs
  outpoint lenUnlockScript unlockingScript nSequence 00 // last byte indicates local anchor
  nOutputs
  outputs...
  nLocktime
// for another example a tx with a merkle proof anchor
  version
  00000000BEEF
  nInputs
  outpoint lenUnlockScript unlockingScript nSequence satoshis lenLockingScript lockingScript 02 // last byte indicates the index of the path from above
  nOutputs
  outputs...
  nLocktime
// repeat for each tx
```

## Backward compatibility

The Background Evaluation Extended Format is not backwards compatible, but has been designed in such a way that existing software should not read a transaction in Background Evaluation Extended Format as a valid (partial) transaction. The Background Evaluation Extended Format header (00000000BEEF) will be read as an empty transaction with a future nLock time in a library that does not support the Background Evaluation Extended Format.

## Implementation

SOONâ„¢
