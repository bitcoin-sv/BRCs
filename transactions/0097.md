# BRC-97: BoltBEEF Transactions

**Author:** Freddie Honohan (freddie@elas.co)

## Abstract

This BRC defines BoltBEEF (Bolt Background Evaluation Extended Format) Transactions, a specialized variant of the [BEEF transaction format (BRC-62)](https://github.com/bitcoin-sv/BRCs/blob/master/transactions/0062.md) and [Atomic BEEF format (BRC-95)](https://github.com/bitcoin-sv/BRCs/blob/master/transactions/0095.md) that optimizes the processing of parent-child transaction pairs. BoltBEEF is designed specifically for the common case where a parent transaction and its immediate child need to be broadcast and validated together as a coherent unit, eliminating the need to create multiple separate BEEF structures for these closely related transactions.

## Motivation
BoltBEEF solves the inefficiency problem that occurs when validators need to process a parent-child transaction pair. Instead of requiring separate Atomic BEEF structures for each transaction, BoltBEEF provides a streamlined format that explicitly represents the parent-child relationship, enabling more efficient processing while maintaining the validation guarantees of the original formats.

BoltBEEF is motivated by the following challenges:

1. **Redundant Data Transmission:** When using multiple BEEF structures for a parent-child transaction pair, the parent transaction would be duplicated, resulting in wasted bandwidth.
2. **Sequential Broadcasting Requirements:** Current BEEF formats don't provide an efficient way to represent this sequential relationship in a single structure.
3. **Pair Validation Efficiency:** Validators can process parent-child transaction pairs more efficiently when they understand the relationship between the two transactions and can validate them in the proper order.
4. **Mempool Management:** For transactions that should enter the mempool together or in sequence, having a format that explicitly defines their relationship helps mining nodes understand the intended processing order.

BoltBEEF addresses these challenges by introducing a structured format that explicitly defines a parent-child transaction pair with their dependencies, allowing for efficient validation of this common transaction sequence.

## Specification

BoltBEEF builds upon the [BEEF (BRC-62)](https://github.com/bitcoin-sv/BRCs/blob/master/transactions/0062.md) and [Atomic BEEF (BRC-95)](https://github.com/bitcoin-sv/BRCs/blob/master/transactions/0095.md) formats with specific structural modifications to represent parent-child transaction pairs efficiently.

### Header Structure

BoltBEEF introduces a simplified header format that identifies the structure type and version.

| Field | Description | Size |
|-------|-------------|------|
| Prefix | Fixed constant 0xb017, indicates the start of a BoltBEEF structure | 2 bytes |
| Version | Version bytes 0x0001 (Major/minor) | 2 bytes |

The version field allows for future extensions and modifications to the format while maintaining backward compatibility. 

### Transaction Inclusion Rules

BoltBEEF enforces that all transactions included in the structure must be part of the dependency graph of either the parent or child transaction. Each transaction must be either:

1. An ancestor transaction required to validate the inputs of either the parent or child transaction.

As with Atomic BEEF, transactions that fall outside of this combined graph are not allowed in BoltBEEF.

### Parent-Child Validation

The validation of a BoltBEEF structure follows these steps:

1. **Pair Identification:**
   - The first transaction in the BoltBEEF structure is treated as the parent transaction.
   - The second transaction in the BoltBEEF structure is treated as the child transaction.

2. **Relationship Validation:**
   - Validate that the child transaction spends at least one output from the parent transaction, confirming a valid parent-child relationship.

3. **Dependency Graph Validation:**
   - For the parent transaction, validate it's complete dependency graphs as per the standard BEEF validation process.
   - For the child transaction, only a subset of it's dependency graph needs to be validated as the already validated parent transaction can be skipped.

4. **Merkle Proof Validation:**
   - As with the original BEEF format, any included transactions that have been mined must be accompanied by ([BSV Universal Merkle Path BUMP](https://github.com/bitcoin-sv/BRCs/blob/master/transactions/0074.md)) data.
   - Process all Merkle proofs to verify that the necessary ancestor transactions are confirmed in the blockchain.
   - BUMP data is not needed nor processed for the child's dependency on the parent given prior validation of it

5. **Sequential Processing:**
   - When broadcasting or processing the transactions, respect the parent-child order defined in the header, processing the parent transaction before the child.

### Optimization Benefits

BoltBEEF offers significant optimization benefits over using multiple Atomic BEEF structures:

- **Reduced Data Size:** The parent transaction and its Merkle proofs are included only once in the structure, reducing data redundancy.
- **Implicit Relationship Representation:** The format uses transaction order to represent the parent-child relationship, making the intended processing order clear to validators.
- **Efficient Validation:** Validators can process the entire parent-child pair in a single validation operation, optimizing computational resources.
- **Simplified Broadcasting:** Services that broadcast transactions can process the pair as a unit, ensuring proper sequential broadcasting without the need for separate structures.
- **Future Extensibility:** The version fields allow for future enhancements while maintaining backward compatibility.

### Error Conditions

BoltBEEF introduces specific error conditions that must cause validation to fail:

- **Invalid Transaction Count:** If the BoltBEEF structure does not contain exactly two transactions (parent and child), validation fails.
- **Invalid Relationship:** If the second transaction (child) does not spend at least one output from the first transaction (parent), validation fails.
- **Unrelated Transactions:** If any transactions in the BEEF structures are not part of the dependency graph of either the parent or child transaction, validation fails.
- **Missing Dependencies:** If any transaction depends on an output from a transaction that is neither in the structure nor has a valid Merkle proof, validation fails.

### Detailed Format Example

#### Bytewise Breakdown

Below is a hexadecimal representation of a simple BoltBEEF structure:
// BoltBEEF header (4 bytes)
b0170001                                            // BoltBEEF prefix (0xb017) + Version 1.0 (0x0001)
// Standard BEEF structure for parent transaction
0100beef                                            // Start of parent standard BEEF structure...
// ... remainder of parent transaction BEEF data ...
// Standard BEEF structure for child transaction
// ... child transaction BEEF data ...
// No Merkle proofs in this simple example
00                                                  // Number of Merkle proofs (0 bytes)


#### Example Use Case

Consider a scenario where a wallet needs to broadcast a funding transaction (parent) and immediately spend its output with a second transaction (child). With BoltBEEF:

1. The wallet creates both transactions, ensuring the child spends an output from the parent.
2. The wallet creates a BoltBEEF structure containing both transactions with the appropriate header.
3. The wallet broadcasts the BoltBEEF structure to a supporting node.
4. The node processes the BoltBEEF structure, validating the parent-child relationship.
5. The node adds both transactions to its mempool in the correct sequence.

This streamlined process eliminates the need for separate BEEF structures and ensures proper efficient sequential validation of the transaction pair.

## Key Efficiencies

### 1. Simplified Header Structure
BoltBEEF significantly reduces overhead compared to using multiple BEEF structures. With just a 4-byte header (prefix + version), the format minimizes metadata while maintaining extensibility through versioning.

### 2. No BUMP Data Required for Parent-Child References
A significant efficiency of BoltBEEF is that BUMP data is **not required** for child transaction inputs that reference outputs from the parent transaction within the same structure. Since the parent transaction is included and validated first within the BoltBEEF structure, there's no need to provide Merkle proofs for outputs spent by the child from that parent.

This optimization:
- Eliminates redundant proof data for newly created outputs
- Substantially reduces the overall size of the data structure
- Streamlines common transaction patterns like "create and spend" operations

BUMP data is only required for inputs that reference transactions not included in the BoltBEEF structure itself, making the format especially efficient for common parent-child transaction flows.

## Implementation Considerations

### Transaction Ordering

When processing a BoltBEEF structure, implementations must respect the transaction ordering:

1. The first transaction is the parent transaction and must be validated first.
2. The second transaction is the child transaction that spends from the parent.
3. If the parent transaction's validation fails, the child transaction is also rejected.
4. Both transactions enter the mempool in the proper sequence.

### Version Handling

The version field in the BoltBEEF header allows for future extensions to the format. Implementations should follow these guidelines for version handling:

1. **Version Compatibility**:
   - The high byte represents the major version, and the low byte represents the minor version.
   - Major version increases (first byte) indicate breaking changes. Implementations should reject BoltBEEF structures with higher major versions than they support.
   - Minor version increases (second byte) indicate backward-compatible additions. Implementations should accept BoltBEEF structures with higher minor versions than they support, ignoring any unrecognized fields.

2. **Version 1.0**:
   - This specification defines version 1.0 (0x0001) of the BoltBEEF format.
   - All implementations should support version 1.0 as the baseline.

3. **Future Versions**:
   - Future versions may add additional fields after the header or modify the semantics of the structure.
   - When a breaking change is required, the major version (first byte) must be incremented.
   - When a backward-compatible change is made, only the minor version (second byte) is incremented.

### Backward Compatibility

BoltBEEF is designed to be easily integrated into systems that already support BEEF (BRC-62) or Atomic BEEF (BRC-95). The unique prefix `0xb017` allows implementations to distinguish BoltBEEF structures from other formats while maintaining similar processing pipelines.

### Future Extensions

While this specification focuses on pairs of transactions, the concept could potentially be extended to longer chains or more complex transaction graphs. Implementations should be designed with the possibility of future extensions in mind.

## References

1. [BEEF (BRC-62)](https://github.com/bitcoin-sv/BRCs/blob/master/transactions/0062.md) - Background Evaluated Extended Format
2. [Atomic BEEF (BRC-95)](https://github.com/bitcoin-sv/BRCs/blob/master/transactions/0095.md) - Atomic Background Evaluated Extended Format
3. [BUMP (BRC-74)](https://github.com/bitcoin-sv/BRCs/blob/master/transactions/0074.md) - BSV Universal Merkle Path