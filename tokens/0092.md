# BRC-92: Via Token Protocol

Deggen (deggen@kschw.com)  

## Abstract

Minimalist protocol for tokenization, issuance, transfer, recovery, and redemption. 

## Motivation

There is a lack of clarity with respect to how tokens can be defined and managed within the context of Overlays. This proposal aims to demonstrate the minimim viable solution for tokens, having considered all available options, picked the most viable, and made small improvements to allow for simple extension of functionality.

## Specification

1. Use a genesis transaction output as an `assetId` concatenating the txid and vout.
2. Push that `assetId` to the stack in any output script you want to send that token to so that overlays, wallets, and smart contracts can evaluate it.
3. Push the `amount` of tokens the output represents if it's a fungible token.
4. Drop the data so that you can use whatever functional logic you like thereafter `...`
5. Prefix everything with a UTF8 exclamation point `!` (0x21 in hex) for sake of measuring adoption.
6. 1 satoshi assigned to each output.

### Fungible Token Script
```xml
21 <assetId> <amount> OP_DROP OP_2DROP ...
```

### NFT Script
```xml
21 <assetId> OP_2DROP ...
```

## Transfers
The sum of input token amounts must equal the sum of output token amounts of the same `assetId`.

![MFT](https://github.com/user-attachments/assets/a4aa7438-3269-40f1-a71f-c3712fdf20c9)

| inputs | outputs |
| --- | --- |
| output holding 9 tokens | `21` `assetId` `04` `OP_DROP` `OP_2DROP` `...` |
|  | `21` `assetId` `05` `OP_DROP` `OP_2DROP` `...` |

The order of inputs and outputs is disregarded.

## Design Justification

### Include Genesis Outpoint In Every Output

Token outputs each refer to the genesis outpoint as a way to avoid collisions when identifying the asset they represent. This acts as a universal asset identifier for enabling swap contracts and token based payment protocols. The randomness helps us avoid things like people competeing to claim the "USD" assetId or other potentially popular labels.

### Why Push Data Formatting?

The only reason to include the data in the outputs at all is for access to the data in smart contracts, any metadata ought to be kept in the application layer if needed. 

Bitcoin Number format is used for the token amount.

Transaction outpoint format is used for the genesis outpoint information.

This is to ensure smart contracts can more easily parse the data within a transaction to enforce conditional logic based on token values, and enforce token type in a format which is already incorporated into the transaction format itself.

### Single Satoshi Outputs

All outputs have 1 satoshi assigned to avoid AML problems like sending “a worthless bean token” to someone which actually has 100 BSV under it.

### Issuer Registration

There is an issuer who is responsible for maintaining the relationship between tokens and the real world assets they represent. The public key used in the locking script should be derived from the identity key of that issuer. The identity key should be certified by a distributed identity system, and shared with the appropriate level of openness for the users interest. If the issuing party is an entity rather than an individual then we can use threshold signatures or multisig.

### Chained Authorization Outpoints

A chain of authorization outpoints is created such that the transaction DAG works as an immutable linked hash chain of all administrative actions taken since genesis. Public audit-ability. No hidden issuances or redemptions. The token supply is known and provable.



Clarification is required specifically with respect to how tokens can be managed in the ecosystem, with businesses looking to take advantage of a public blockchain for transparency and robustness, while also allowing regulatory controls to be put in place for compliance purposes.


## Implementations



## References

